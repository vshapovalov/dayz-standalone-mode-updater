MANDATORY TASK LOGGING (do this before any other work):\n1) Ensure there is a directory named `tasks/` at repo root (create if missing).\n2) Determine the next task number by listing existing files `tasks/task_*.md`:\n   - If none exist, start with task number = 1.\n   - Otherwise, set task number = (max existing number + 1).\n3) Create a new markdown file: `tasks/task_{N}.md`.\n4) Save the FULL EXACT PROMPT TEXT (verbatim) into that file, including this mandatory logging block and everything below it.\n5) Only after the file is created, proceed with implementing the task.\n\n\nImplement Workshop metadata polling (every workshop_poll_seconds).\n\nUse Steam Web API:\n- POST https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/\n- Parameters: itemcount, publishedfileids[0..N-1]\n- Parse response details and read time_updated (unix seconds). Store as RFC3339 timestamps in state.\n- If config.steam.web_api_key is non-empty, include key=<...> param (support both key/no-key).\n\nBatching:\n- Use config.concurrency.workshop_batch_size (e.g. 50-100).\n- Use config.concurrency.workshop_parallelism to limit concurrent HTTP calls.\n- Cache last_workshop_check_at and avoid rechecking more often than workshop_poll_seconds.\n\nLogic:\n- candidate_mods = union of servers[*].last_mod_ids from state.\n- For each mod:\n  - update mods[id].workshop_updated_at if newer\n  - update mods[id].last_workshop_check_at = now\n- Determine mods_to_update_locally where workshop_updated_at > local_updated_at OR local_updated_at is null.\n- Do NOT run SteamCMD here yet; just return list to orchestrator.\n\nAdd unit tests:\n- response JSON parsing for time_updated\n- batching logic\n- “needs local update” decision\n\nReturn code changes by file path.
